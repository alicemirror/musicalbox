/**
 * \file Carillon.ino
 * \brief Arduino mp3 player and the other stuff for the Arduino version of the Carillon project
 * 
 * Board: Arduino mini pro 328p 3.3V 16 MHz (VCC should be 5V on the board)
 * 
 * @note The player uses the same serial used also to program the Nano via USB to when a new program should
 * be uploaded the serial wires should be disconnected. For more details on the DFPlayerMini Arduino library 
 * please read the GitHub (sources docmentation includes more detailed information than the wiki). Read the 
 * DFRobotDFPlayerMini.h header file fo the constant definitions to set all the parameters.\n
 * Using Arduino Mega or Mega2560 platforms you can set the player serial to one different than the USB serial
 * e.g. Serial1
 * 
 * @warning If you copy the files on the microSD card with a Mac OS remember to launch from the terminal
 * the command dot_clean /Volumes/<SDVolumeName> before removind the microSD card. This deletes the dot files
 * automatically generated by the OSX that create noisy silent playing of undesired ghost files.
 * 
 * @note The mp3 files should be named in sequence 001.mp3 ... xxx.mp3. Files can be organized in folders
 * named in sequence 01 .. nn and every folder can contain a max of 255 files.
 * The DF PLayer support microSD cards up to 32 Gb. For more details read the datasheet in the Doc folder of the
 * repository.
 * 
 * This source and the other components of the carousel project are available on GitHub pages at the address
 * <https://alicemirror.github.io/Carillon>
 * 
 * @author Enico Miglino <balearicdynamics@gmail.com>
 * @license LGPL 3.0
 * @versione 1.0.0
 * @date June 2019
 */

#include "globals.h"

//! Instance of the DF mp player class
DFRobotDFPlayerMini libDFPlayer;
//! Player control structure
SoundControl playerControl;

// =============================================================
//                    Player Functions
// =============================================================

//! Initialize the player start parameters
void initPlayer() {
  //Set serial communictaion time out 500ms
  libDFPlayer.setTimeOut(SERIAL_TIMEOUT); 
  //----Set device we uset----
  libDFPlayer.reset();     //Reset the module
  delay(COMMAND_DELAY);
  //----Set volume----
  libDFPlayer.volume(playerControl.volume);  //Set volume value (0~30).
  delay(COMMAND_DELAY);
  //----Set Equalization----
  libDFPlayer.EQ(DFPLAYER_EQ_CLASSIC);
  delay(COMMAND_DELAY);
  //----Set device we uset----
  libDFPlayer.outputDevice(MP3_DEVICE);
  delay(COMMAND_DELAY);
}

/**
 * Set the dynamic max volume as a fixed value, no volume control
 * is used in this version
 */
void getDynamicVolume() {
  playerControl.maxVolume = MAX_VOLUME;
}

/**
 * Increase the current volume of one step. If the volume is already to the max value
 * the volume is reset to minimum
 */
void stepVolume() {
  int j;

  // Read the current max volume limit (may vary if a trigger is added to analog port)
  getDynamicVolume();

  // Increment the volume of the predefined steps
  playerControl.volume += VOLUME_STEPS;

  // If we reached the max the volume is set to min
  if(playerControl.volume > MAX_VOLUME) {
    playerControl.volume = START_VOLUME;
  }
  // Adjust the volume accordingly
  libDFPlayer.volume(playerControl.volume);
}

/**
 * Check the status of the player trigger and return the corresponding boolean status
 */
void isTrigger() {
  if(digitalRead(TRIGGER_PIN) == LOW) {
    digitalWrite(TRIGGER_LED, HIGH);
    playerControl.trigger = true;  
  }
  else {
    digitalWrite(TRIGGER_LED, LOW);
    playerControl.trigger = false;  
  }
}

/**
 * Check the status of the next song pin. Works only if already playing.
 * 
 * If the pin is set (low) the song is stopped (if not yet) and the next song
 * is started.
 */
boolean isNextSong() {
  if(digitalRead(NEXTSONG_PIN) == LOW) {
    return true;  
  }
  else {
    return false;  
  }
}

/**
 * Check the status of the volume pin. Works only if already playing.
 * 
 * If the pin is set (low) the volume is updated cyclic.
 */
boolean isChangeVolume() {
  if(digitalRead(VOLUMESONG_PIN) == LOW) {
    return true;  
  }
  else {
    return false;  
  }
}

/**
 * Play the next song of the list. If the last has been played, restart
 * from the first.
 * 
 * @note The next song is controlled by the playerControl structure and instead
 * of using the library next() call the current song is played.
 */
void nextSong() {
  // Update the song
  playerControl.currentSong++;
  if(playerControl.currentSong > MAX_SONGS) {
    // Reset the song counter
    playerControl.currentSong = 1;
  } // Updated player status and song
}

// =============================================================
//                    setup() & loop()
// =============================================================

//! Initialization function
void setup() {
  Serial.begin(SERIAL_SPEED);

  pinMode(TRIGGER_PIN, INPUT_PULLUP);
  pinMode(NEXTSONG_PIN, INPUT_PULLUP);
  pinMode(VOLUMESONG_PIN, INPUT_PULLUP);
  pinMode(TRIGGER_LED, OUTPUT);

  libDFPlayer.begin(Serial);
  delay(1000);

  // Wait until the Arduino serial connect the player
  if (!libDFPlayer.begin(Serial)) {
    while(true);
  }

  initPlayer();
}

/**
 * Main loop
 */
void loop()
{
  // Check the start/stop trigger
  isTrigger();

  // Check if the trigger is active
  if(playerControl.trigger == true) {
    // --------------------------------- Check if is already playing else start playing
    if(playerControl.isPlaying == false) {
      playerControl.isPlaying = true;
      // Start playing 
      libDFPlayer.play(playerControl.currentSong);
      delay(500);
    } // Playing started
  } // Trigger is set for playing
  else {
    // Trigger is not active, check if is playing and fade out the song
    if(playerControl.isPlaying == true)
    // Put the player in pause
    libDFPlayer.pause();
    nextSong();
    playerControl.isPlaying = false;
  } // Playing stopped
}
